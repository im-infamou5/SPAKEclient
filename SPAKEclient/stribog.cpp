#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>
#include <sstream>
#include <string>
#include <bitset>
#include "stribog_data.h" 
#include "crypto.h"


using std::stringstream;
using std::string;
using std::bitset;
using Crypto::Stribog;

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#include "stribog_data.h"

void hexPrinter(unsigned char* c, int l)
{

	while (l > 0)
	{
		printf("%02x", *c);
		l--;
		c++;
	}
	printf("\n");
}


void Stribog::AddModulo512(const unsigned char *a, const unsigned char *b, unsigned char *c)
{
	int i = 0, t = 0;

	for (i = 63; i >= 0; i--)
	{
		t = a[i] + b[i] + (t >> 8);
		c[i] = t & 0xFF;
	}
}

void Stribog::AddXor512(const void *a, const void *b, void *c)
{
	int i = 0;
	long long *A = (long long*)a, *B = (long long*)b;
	unsigned long long *C = (unsigned long long*)c;

	for (i = 0; i<8; i++)
	{
		C[i] = A[i] ^ B[i];
	}
}

void Stribog::S(unsigned char *state)
{
	int i = 0;

	for (i = 0; i<64; i++)
	{
		state[i] = Sbox[state[i]];
	}
}

void Stribog::L(unsigned char *state)
{
	unsigned long long v = 0;
	int i = 0, j = 0, k = 0;

	for (i = 0; i<8; i++)
	{
		v = 0;
		for (k = 0; k<8; k++)
		{
			for (j = 0; j<8; j++)
			{
				if ((state[i * 8 + k] & (1 << (7 - j))) != 0)
					v ^= A[k * 8 + j];
			}
		}
		for (k = 0; k<8; k++)
		{
			state[i * 8 + k] = (v & ((unsigned long long)0xFF << (7 - k) * 8)) >> (7 - k) * 8;
		}
	}
}

void Stribog::P(unsigned char *state)
{
	int i = 0;
	unsigned char t[64] = {};

	for (i = 0; i<64; i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state, t, 64);
}

void Stribog::KeySchedule(unsigned char *K, int i)
{
	AddXor512(K, C[i], K);

	S(K);
	P(K);
	L(K);
}

void Stribog::E(unsigned char *K, const unsigned char *m, unsigned char *state)
{
	int i = 0;

	memcpy(K, K, 64);

	AddXor512(m, K, state);

	for (i = 0; i<12; i++)
	{
		S(state);
		P(state);
		L(state);
		KeySchedule(K, i);
		AddXor512(state, K, state);
	}
}

void Stribog::g_N(const unsigned char *N, unsigned char *h, const unsigned char *m)
{
	unsigned char t[64], K[64];

	AddXor512(N, h, K);

	S(K);
	P(K);
	L(K);

	E(K, m, t);

	AddXor512(t, h, t);
	AddXor512(t, m, h);
}

void Stribog::hash_X(unsigned char *IV, char *message, unsigned long long length, unsigned char *out)
{
	unsigned char v512[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00
	};
	unsigned char v0[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char Sigma[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char N[64] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	unsigned char m[64], *hash = IV;
	unsigned long long len = length;

	// Stage 2
	while (len >= 512)
	{
		memcpy(m, message + len / 8 - 63 - ((len & 0x7) == 0), 64);

		g_N(N, hash, m);
		AddModulo512(N, v512, N);
		AddModulo512(Sigma, m, Sigma);
		len -= 512;
	}

	memset(m, 0, 64);
	memcpy(m + 63 - len / 8 + ((len & 0x7) == 0), message, len / 8 + 1 - ((len & 0x7) == 0));

	// Stage 3
	m[63 - len / 8] |= (1 << (len & 0x7));

	g_N(N, hash, m);
	v512[63] = len & 0xFF;
	v512[62] = len >> 8;
	AddModulo512(N, v512, N);

	AddModulo512(Sigma, m, Sigma);

	g_N(v0, hash, N);
	g_N(v0, hash, Sigma);

	memcpy(out, hash, 64);

}

void Stribog::hash512(char *message, unsigned long long length, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	hash_X(IV, message, length, out);
	hexPrinter(out, 64);
}

void Stribog::hash256(char *message, unsigned long long length, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
	};
	unsigned char hash[64];

	hash_X(IV, message, length, hash);

	memcpy(out, hash, 32);
	hexPrinter(out, 32);
}
/*
bool Stribog::selftest()
{
	string val1 = "210987654321098765432109876543210987654321098765432109876543210";
	string val1_512hash = "486f64c1917879417fef082b3381a4e211c324f074654c38823a7b76 \
		f830ad00fa1fbae42b1285c0352f227524bc9ab16254288dd6863dccd5b9f54a1ad0541b";
	string val1_256hash = "00557be5e584fd52a449b16b0251d05d27f94ab76cbaa6da890b59d8ef1e159d";
	string val2 = "ыверогИ ыкълп яырбарх ан ималертс яром с ътюев, ицунв ижобиртС, иртев еС";
	string val2_512hash = "28fbc9bada033b1460642bdcddb90c3fb3e56c497ccd0f62b8a2ad493 \
		5e85f037613966de4ee00531ae60f3b5a47f8dae06915d5f2f194996fcabf2622e6881e";
	string val2_256hash = "508f7e553c06501d749a66fc28c6cac0b005746d97537fa85d9e40904efed29d";
	string out;
	
	hash256(val1, val1.length(), out);
	if (!out.compare(val1_256hash))
	{
		return false;
	}

	hash256(val2, val1.length(), out);
	if(!out.compare(val2_256hash))
	{
		return false;
	}
	
	return true;

}
*/
/*
void Stribog::hash512(string message, unsigned long long length, string &out)
{
	const unsigned char* msg;
	unsigned char* res;
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	msg = (const unsigned char*)malloc(length + 1);
	res = (unsigned char*)malloc(length + 1);
	hash_X(IV, msg, length, res); // длина передается в битах

	string str((reinterpret_cast<const char*>(msg)));
	out = str;
	
	free(reinterpret_cast<void*>(const_cast<unsigned char *>(msg)));
	free(reinterpret_cast<void*>(const_cast<unsigned char *>(res)));
}
void Stribog::hash256(string message, unsigned long long length, string &out)
{
	const unsigned char* msg;
	unsigned char* res;
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	msg = (const unsigned char*)malloc(length + 1);
	res = (unsigned char*)malloc(length + 1);
	for (int i = 0; i < length + 1; i++)
	{
		memcpy_s((void *)msg, length, message.c_str(), length);
	}
	
	hash_X(IV, msg, length+1, res); // длина передается в битах

	string str((reinterpret_cast<const char*>(msg)));
	out = str;

	free(reinterpret_cast<void*>(const_cast<unsigned char *>(msg)));
	free(reinterpret_cast<void*>(const_cast<unsigned char *>(res)));
}
*/
/*
void Stribog::hash_pass_256(const unsigned char *message, unsigned long long length, unsigned iteration_count, unsigned char *salt, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	stringstream salted_pass;
	char *str;
	std::string s;
	int i = 0, len = 0;
	salted_pass << message;
	salted_pass << salt;

	s = salted_pass.str();
	len = s.length();
	str = new char[64];
	strcpy_s(str, len, s.c_str());
	for (int i = 0; i < iteration_count; i++)
	{
		hash_X(IV, (unsigned char *)str, length * 8, out); // длина передается в битах
		*str = *out;
	}
	delete [] str;
}

void Stribog::hash_pass_512(const unsigned char *message, unsigned long long length, unsigned iteration_count, unsigned char *salt, unsigned char *out)
{
	unsigned char IV[64] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	stringstream salted_pass;
	char *str;
	std::string s;
	int i = 0, len = 0;
	salted_pass << message;
	salted_pass << salt;

	s = salted_pass.str();
	len = s.length();
	str = new char [64];
	strcpy_s(str, len, s.c_str());
	for (int i = 0; i < iteration_count; i++)
	{
		hash_X(IV, (unsigned char *)str, length*8, out); // длина передается в битах
		*str = *out;
	}
	delete [] str;
}
*/
